---
id: 03接口_v3.7
title: 接口
---

## 简介

TypeScript 的核心原则之一是类型检查的重点是检查 Shape（*~觉得只能用英文才能表示这个意思*），**?This is sometimes called “duck typing” or “structural subtyping”**，在 TypeScript 中，接口充当为这些类型命名的角色，并且也是项目对内对外约定代码的有效方法。

## 第一个接口

要了解接口是如何工作的，最容易的方法就是从一个简单的例子开始。
<!--JavaScript-->

```js
function printLabel(labeledObj: { label: string }) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

类型检查器检查对 printLabel 的调用，printLabel 函数只有一个参数并且要求调用时传入的对象必须具有 string 类型的属性 label，注意代码中定义的对象 myObj 实际上还有其他属性，但编译器只检查函数参数中声明的属性及其类型。很多情况下 TypeScript 语法检查都不太宽松，我们将大概介绍一下。

现在再次修改代码，这次使用接口来描述 label 属性。
<!--JavaScript-->

```js
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

现在我们可以使用 `LabeledValue` 来描述上面例子中的代码语义，这个接口仍然是说有一个类型为 string 的 label 属性。注意：我们不需要像其他语言那样要求传入的参数在语法上明确实现这个接口，`Shape` 才是最重要的，如果传入函数的参数满足接口列出的规则，那代码就可以正常执行。

必须要说明的是类型检查器不关心属性定义时的先后顺序，只检查对象的属性及其类型是否符合接口声明的 `Shaple`。

## 可选属性

接口中定义的属性并不都是必须要有的，一些属性在某些情况下存在或根本就不存在，当在创建类似具有动态属性的对象的时候，可选属性是非常适用的，传递到函数中的对象只有部分属性。

下面是一个这种用法的例子。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

拥有可选属性的接口的定义方式和其他接口类似，只是在声明的时候需要在可选属性的属性名后面跟一个 `?`。

可选属性的好处在于可以定义可能存在的属性，同时又能防止使用不属于接口的属性。例如，如果我们在 `createSquare` 函数中输错了属性 `color` 的名字，将会返回错误。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    let newSquare = {color: "white", area: 100};
    if (config.clor) {
        // Error: Property 'clor' does not exist on type 'SquareConfig'
        newSquare.color = config.clor;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

## 只读属性

某些属性只能在对象首次创建的时候被修改，我们可以在属性名前面放上 `readonly` 关键字。
<!--JavaScript-->

```js
interface Point {
    readonly x: number;
    readonly y: number;
}
```

你可以使用创建对象的简单语法创建一个 `Point` 对象，在创建之后，`x` 和 `y` 的值就不能再修改。
<!--JavaScript-->

```js
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```

TypeScript 有一个与 `Array<T>` 相同的 `ReadonlyArray<T>` 类型，只读数组移除了所有可修改数组本身的方法，所以你可以确保一旦数组被创建后这个数组就不会再被人修改。
<!--JavaScript-->

```js
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

在代码段的最后一行，可以看到，即使将整个只读数组重新赋值给普通数组也是非法的。但是你仍然可以使用类型推断语法来实现重新赋值。
<!--JavaScript-->

```js
a = ro as number[];
```

### readonly vs const

究竟是使用 readonly 还是 const，最简单的方法就是看你是在属性上使用还是在变量上使用，变量使用 const 而属性使用 readonly。

## 多余属性检查

在之前的例子中我们使用了接口，TypeScript 允许我们的接口定义时的 `Shape` 为 `{ label: string; }` 但是对象的实际 `Shape` 为 `{ size: number; label: string; }`。我们也了解了可选属性，当创建具有动态属性的对象的时候非常有用。

但是如果将二者混用可能就会出些问题了，下面我们来看有关 `createSquare` 函数的最后一个例子。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
```

## 函数类型

## 可索引类型

## 类类型

## 接口继承

## 混合类型

## 接口实现类