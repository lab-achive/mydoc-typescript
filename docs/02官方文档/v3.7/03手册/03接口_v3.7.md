---
id: 03接口_v3.7
title: 接口
---

## 简介

TypeScript 的核心原则之一是类型检查的重点是检查 Shape（*~觉得只能用英文才能表示这个意思*），**?This is sometimes called “duck typing” or “structural subtyping”**，在 TypeScript 中，接口充当为这些类型命名的角色，并且也是项目对内对外约定代码的有效方法。

## 第一个接口

要了解接口是如何工作的，最容易的方法就是从一个简单的例子开始。
<!--JavaScript-->

```js
function printLabel(labeledObj: { label: string }) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

类型检查器检查对 printLabel 的调用，printLabel 函数只有一个参数并且要求调用时传入的对象必须具有 string 类型的属性 label，注意代码中定义的对象 myObj 实际上还有其他属性，但编译器只检查函数参数中声明的属性及其类型。很多情况下 TypeScript 语法检查都不太宽松，我们将大概介绍一下。

现在再次修改代码，这次使用接口来描述 label 属性。
<!--JavaScript-->

```js
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

现在我们可以使用 `LabeledValue` 来描述上面例子中的代码语义，这个接口仍然是说有一个类型为 string 的 label 属性。注意：我们不需要像其他语言那样要求传入的参数在语法上明确实现这个接口，`Shape` 才是最重要的，如果传入函数的参数满足接口列出的规则，那代码就可以正常执行。

必须要说明的是类型检查器不关心属性定义时的先后顺序，只检查对象的属性及其类型是否符合接口声明的 `Shaple`。

## 可选属性

接口中定义的属性并不都是必须要有的，一些属性在某些情况下存在或根本就不存在，当在创建类似具有动态属性的对象的时候，可选属性是非常适用的，传递到函数中的对象只有部分属性。

下面是一个这种用法的例子。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

拥有可选属性的接口的定义方式和其他接口类似，只是在声明的时候需要在可选属性的属性名后面跟一个 `?`。

可选属性的好处在于可以定义可能存在的属性，同时又能防止使用不属于接口的属性。例如，如果我们在 `createSquare` 函数中输错了属性 `color` 的名字，将会返回错误。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    let newSquare = {color: "white", area: 100};
    if (config.clor) {
        // Error: Property 'clor' does not exist on type 'SquareConfig'
        newSquare.color = config.clor;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

## 只读属性

某些属性只能在对象首次创建的时候被修改，我们可以在属性名前面放上 `readonly` 关键字。
<!--JavaScript-->

```js
interface Point {
    readonly x: number;
    readonly y: number;
}
```

你可以使用创建对象的简单语法创建一个 `Point` 对象，在创建之后，`x` 和 `y` 的值就不能再修改。
<!--JavaScript-->

```js
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```

TypeScript 有一个与 `Array<T>` 相同的 `ReadonlyArray<T>` 类型，只读数组移除了所有可修改数组本身的方法，所以你可以确保一旦数组被创建后这个数组就不会再被人修改。
<!--JavaScript-->

```js
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

在代码段的最后一行，可以看到，即使将整个只读数组重新赋值给普通数组也是非法的。但是你仍然可以使用类型推断语法来实现重新赋值。
<!--JavaScript-->

```js
a = ro as number[];
```

### readonly vs const

究竟是使用 readonly 还是 const，最简单的方法就是看你是在属性上使用还是在变量上使用，变量使用 const 而属性使用 readonly。

## 额外属性检查

在之前的例子中我们使用了接口，TypeScript 允许我们的接口定义时的 `Shape` 为 `{ label: string; }` 但是对象的实际 `Shape` 为 `{ size: number; label: string; }`。我们也了解了可选属性，当创建具有动态属性的对象的时候非常有用。

但是如果将二者混用可能就会出些问题了，下面我们来看有关 `createSquare` 函数的最后一个例子。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
```

注意传给 createSquare 函数的参数是 `colour` 而不是 `color`，在一般的 JavaScript 语法中，这样传值会失败。

你可能会说程序没有什么问题啊，width 属性没有问题，只是 color 属性没有指定，但是没有 color 属性问题也不大嘛。

但是 TypeScript 认为代码中可能有 BUG，在将对象字面量分配给其他变量或将其作为参数传递时，会对其进行特殊处理并进行额外的属性检查，如果对象字面量含有任何目标类型没有的属性，将会返回错误。

*~这里着重介绍一下所谓的对象字面量，我们向 createSquare 函数传值有两种方法，一种是定义好对象后传入整个对象，一种是使用对象字面量，如下两种方式。*

定义好对象传入整个对象：
<!--JavaScript-->

```js
let x = {
  width: 1,
  color: "red"
}

let mySquare = createSquare(x);
```

使用对象字面量：
<!--JavaScript-->

```js
let mySquare = createSquare({width: 1, color: "red"});
```

*~这里所说的对象字面量就是指后一种传值方法。*

<!--JavaScript-->

```js
// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

解决这些检查其实很简单，最简单的方法就是使用类型推断。
<!--JavaScript-->

```js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

>*~其实也可以先把 `{ width: 100, opacity: 0.5 }` 提前定义好，使用一个变量来引用。*

但是如果你确定对象有一些额外的属性，添加字符串索引签名可能是更好的办法。如果 SquareConfig 有 color 和 width 属性，但是仍有一些其他属性，我们可以这样定义。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

接下来将讨论一下这种方式，这种方式的意思是 SquareConfig 可以有很多的属性，只要属性名不是 color 和 width，他们的类型无所谓。

解决这种语法检查的最后一种方法，大家可能有点惊讶，仅仅只需要把对象指定给一个变量就可以了，由于 squareOptions 不会进行过多的属性检查，所以编译器不会报错。
<!--JavaScript-->

```js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

只要在 squareOptions 和 SquareConfig 之间具有共有的属性，上面的方法就有效。在上面的例子中，width 就是二者都共有的属性。如果二者之间没有任何的公共属性，那么上面这种方法仍然会失效。
<!--JavaScript-->

```js
let squareOptions = { colour: "red" };
let mySquare = createSquare(squareOptions); // Error，两种类型没有共有的属性。
```

请记住，对于上述简单代码，或许不应该尝试去规避这些检查。对那些还含有方法和持有状态的复杂对象字面量，需要时刻注意这些技巧，大多数由额外属性造成的错误实际上都是程序 BUG。这意味着如果遇到像 `option bags` 那样的额外属性检查时，你可能需要修改一下类型声明。在这种情况下，如果传递具有 color 和 colour 属性的对象到 createSquare 函数没问题，那我们应该修正 SquareConfig 的定义。

## 函数类型

接口可以定义 JavaScript 能够使用的对象的 `Shape`、对象的属性。接口还可以定义函数类型。

使用接口定义函数类型，我们给接口定义一个函数的签名，这有点像使用参数列表和返回类型来声明函数一样，参数列表中的每一个参数都需要声明名字和类型。
<!--JavaScript-->

```js
interface SearchFunc {
    (source: string, subString: string): boolean;
}
```

一旦定义好了函数，我们可以像使用其他接口一样使用函数类型的接口。下面是如何创建一个函数类型的变量以及给它赋予相应类型的函数的方法。
<!--JavaScript-->

```js
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    let result = source.search(subString);
    return result > -1;
}
```

函数类型的类型检查不要求参数名字一定要匹配，上面这个例子我们也可以改造成这样。
<!--JavaScript-->

```js
let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
    let result = src.search(sub);
    return result > -1;
}
```

函数的参数会被检查，但检查的是相应位置的参数的类型，如果你不想指定参数的类型，TypeScript 可以根据函数 SearchFunc 实例化时的值来推断参数的类型。同样函数的返回类型也是由返回值隐式声明的。
<!--JavaScript-->

```js
let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result > -1;
}
```

如果函数表达式返回数字或者字符串，类型检查器会提示错误，说明函数的返回值与接口 SearchFunc 中定义的返回值不匹配。
<!--JavaScript-->

```js
let mySearch: SearchFunc;

// error: Type '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.
// Type 'string' is not assignable to type 'boolean'.
mySearch = function(src, sub) {
  let result = src.search(sub);
  return "string";
};
```

## 可索引类型

和我们使用接口定义函数类型一样，接口也可以定义可索引的类型，如：`a[10]` 或者 `ageMap["daniel"]`，可索引类型定义我们可以用来在对象上执行索引动作的索引标识符（*~的类型*），同时定义索引返回值的类型。
<!--JavaScript-->

```js
interface StringArray {
    [index: number]: string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
```

这里有一个具有索引标识符的 `StringArray` 接口，索引标识符声明当 `StringArray` 使用一个 `number` 类型的值进行查找时将返回一个 `string`。

索引标识符支持两种类型：`number` 和 `string`，可以同时支持两种类型的索引方式，但是数字索引方式返回的类型必须是字符串索引方式返回的类型的子类型。因为当使用数字索引方式的时候，JavaScript 在索引对象之前实际上是先把数字转换为字符，然后再执行索引查找的。也就是说，使用 100（数字）和 "100"（字符）执行索引查找时一样的，所以二者要保持一致。
<!--JavaScript-->

```js
class Animal {
    name: string;
}
class Dog extends Animal {
    breed: string;
}

// Error: indexing with a numeric string might get you a completely separate type of Animal!
interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}
```

字符索引标识符对于描述 `字典` 类的结构是一种好方法，字符索引标识符还强制规定所有属性的类型必须与索引标识符索引查找后返回的值的类型一致，因为 `obj.property` 也可以用 `obj["property"]` 来表示，在下面的例子中，属性 `name` 的类型与字符索引标识符的返回类型不一致，类型检查器将返回错误。
<!--JavaScript-->

```js
interface NumberDictionary {
    [index: string]: number;
    length: number;    // ok, length is a number
    name: string;      // error, the type of 'name' is not a subtype of the indexer
}
```

但是，如果索引标识符声明的返回类型是联合类型，那么类型不匹配的属性是可以存在的。
<!--JavaScript-->

```js
interface NumberOrStringDictionary {
    [index: string]: number | string;
    length: number;    // ok, length is a number
    name: string;      // ok, name is a string
}
```

你也可以指定索引标识符为 `readonly`，这样可以避免对相应的索引重新赋值。
<!--JavaScript-->

```js
interface ReadonlyStringArray {
    readonly [index: number]: string;
}
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[2] = "Mallory"; // error!
```

因为索引标识符声明为 readonly，所以你不能对 `myArray[2]` 重新指定值。

## 类类型

### 实现接口

在 C# 或 Java 中接口最常见的用法就是规定类必须实现某些接口中的约定，在 TypeScript 中也没问题。

<!--JavaScript-->

```js
interface ClockInterface {
    currentTime: Date;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    constructor(h: number, m: number) { }
}
```

接口也可以定义在类里面要实现的方法，下面的代码中我们用 `setTime` 作演示。
<!--JavaScript-->

```js
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date): void;
}

class Clock implements ClockInterface {
    currentTime: Date = new Date();
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
```

接口描述的是类的公开部分功能或属性，不包括类的私有部分。不要在接口中声明类的私有部分功能或属性。

### static 和类实例的区别

当在使用类和接口的时候，记住类是由两部分组成：static 部分和实例部分，你可能注意到了如果你在定义接口的时候使用了构造标识符 `new`，当你在创建一个类并实现该接口时会返回错误。
<!--JavaScript-->

```js
interface ClockConstructor {
    new (hour: number, minute: number);
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
```

这是因为当类实现接口的时候，只有类的实例部分会被检查，由于构造函数属于类的 static 部分，所以不会被检查。

你需要直接使用类的静态部分，在下面的例子中，我们定义了两个接口，一个接口 `ClockConstructor` 里面定义的是构造标识符 `new`，另一个接口 `ClockInterface`
定义的是实例方法.为了方便，我们定义了一个构造函数 `createClock`，这个函数使用参数来创建对应的实例。
<!--JavaScript-->

```js
interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}
interface ClockInterface {
    tick(): void;
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep");
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock");
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
```

因为 createClock 的第一个参数的类型是 ClockConstructor，在代码 `createClock(AnalogClock, 7, 32)` 中，需要检查 AnalogClock 是否有正确的构造方法签名。

另一个更简单的方式是使用类表达式。
<!--JavaScript-->

```js
interface ClockConstructor {
  new (hour: number, minute: number);
}

interface ClockInterface {
  tick();
}

const Clock: ClockConstructor = class Clock implements ClockInterface {
  constructor(h: number, m: number) {}
  tick() {
      console.log("beep beep");
  }
}
```

## 接口继承

像类一样，接口也可以互相继承，接口继承可以复制一个接口的成员到另外一个接口中，你可以把接口拆得更简洁明了以便于组件的重用。
<!--JavaScript-->

```js
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
```

接口可以继承自多个接口，这样可以创建多个接口的组合。
<!--JavaScript-->

```js
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = {} as Square;
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```

## 混合类型

我们之前说过，接口可以定义 JavaScript 中的各种类型，由于 JavaScript 具有动态和灵活的特性，有时可能会遇到一个对象，该对象是某些类型的组合。

这里这个例子对象既是函数又是对象，对象还具有一些额外的属性。
<!--JavaScript-->

```js
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = (function (start: number) { }) as Counter;
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

当与第三方 JavaScript 库协作时，你可以使用上面的方法。

## 继承自类的接口

当接口继承自类的时候，接口会继承类的成员，但不继承其实现。就有点类似接口声明了类的所有成员而没有提供实现。接口甚至会继承基类的私有成员和受保护成员。这意味着当创建一个接口来扩展具有私有成员或受保护成员的类时，该接口只能由该类或其子类实现。

当具有较深的继承层次结构，但要指定代码仅适用于具有某些属性的子类时，这很有用。子类只能从基类继承。
<!--JavaScript-->

```js
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// Error: Property 'state' is missing in type 'Image'.
class Image implements SelectableControl {
    private state: any;
    select() { }
}

class Location {

}
```

在上面的例子中，SelectableControl 继承了类 Control 的所有成员，包括私有的 state 属性，由于 state 是私有成员，所以只有 Control 的子类才能实现 SelectableControl 接口，因为只有 Control 的子类才会有来自父类的 state 私有成员，这是存在私有成员是必须满足的要求。

在 Control 类中，可以通过 SelectableControl 的实例访问私有成员。SelectableControl 的行为类似于有 select 方法的 Control，Button 和 TextBox 类是 SelectableControl 的子类（因为它们都继承自 Control 并且具有 select 方法），而 Image 和 Location 类则不是。
