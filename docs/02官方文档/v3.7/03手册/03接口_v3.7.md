---
id: 03接口_v3.7
title: 接口
---

## 简介

TypeScript 的核心原则之一是类型检查的重点是检查 Shape（*~觉得只能用英文才能表示这个意思*），**?This is sometimes called “duck typing” or “structural subtyping”**，在 TypeScript 中，接口充当为这些类型命名的角色，并且也是项目对内对外约定代码的有效方法。

## 第一个接口

要了解接口是如何工作的，最容易的方法就是从一个简单的例子开始。
<!--JavaScript-->

```js
function printLabel(labeledObj: { label: string }) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

类型检查器检查对 printLabel 的调用，printLabel 函数只有一个参数并且要求调用时传入的对象必须具有 string 类型的属性 label，注意代码中定义的对象 myObj 实际上还有其他属性，但编译器只检查函数参数中声明的属性及其类型。很多情况下 TypeScript 语法检查都不太宽松，我们将大概介绍一下。

现在再次修改代码，这次使用接口来描述 label 属性。
<!--JavaScript-->

```js
interface LabeledValue {
    label: string;
}

function printLabel(labeledObj: LabeledValue) {
    console.log(labeledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

现在我们可以使用 `LabeledValue` 来描述上面例子中的代码语义，这个接口仍然是说有一个类型为 string 的 label 属性。注意：我们不需要像其他语言那样要求传入的参数在语法上明确实现这个接口，`Shape` 才是最重要的，如果传入函数的参数满足接口列出的规则，那代码就可以正常执行。

必须要说明的是类型检查器不关心属性定义时的先后顺序，只检查对象的属性及其类型是否符合接口声明的 `Shaple`。

## 可选属性

接口中定义的属性并不都是必须要有的，一些属性在某些情况下存在或根本就不存在，当在创建类似具有动态属性的对象的时候，可选属性是非常适用的，传递到函数中的对象只有部分属性。

下面是一个这种用法的例子。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
    let newSquare = {color: "white", area: 100};
    if (config.color) {
        newSquare.color = config.color;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

拥有可选属性的接口的定义方式和其他接口类似，只是在声明的时候需要在可选属性的属性名后面跟一个 `?`。

可选属性的好处在于可以定义可能存在的属性，同时又能防止使用不属于接口的属性。例如，如果我们在 `createSquare` 函数中输错了属性 `color` 的名字，将会返回错误。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    let newSquare = {color: "white", area: 100};
    if (config.clor) {
        // Error: Property 'clor' does not exist on type 'SquareConfig'
        newSquare.color = config.clor;
    }
    if (config.width) {
        newSquare.area = config.width * config.width;
    }
    return newSquare;
}

let mySquare = createSquare({color: "black"});
```

## 只读属性

某些属性只能在对象首次创建的时候被修改，我们可以在属性名前面放上 `readonly` 关键字。
<!--JavaScript-->

```js
interface Point {
    readonly x: number;
    readonly y: number;
}
```

你可以使用创建对象的简单语法创建一个 `Point` 对象，在创建之后，`x` 和 `y` 的值就不能再修改。
<!--JavaScript-->

```js
let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
```

TypeScript 有一个与 `Array<T>` 相同的 `ReadonlyArray<T>` 类型，只读数组移除了所有可修改数组本身的方法，所以你可以确保一旦数组被创建后这个数组就不会再被人修改。
<!--JavaScript-->

```js
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

在代码段的最后一行，可以看到，即使将整个只读数组重新赋值给普通数组也是非法的。但是你仍然可以使用类型推断语法来实现重新赋值。
<!--JavaScript-->

```js
a = ro as number[];
```

### readonly vs const

究竟是使用 readonly 还是 const，最简单的方法就是看你是在属性上使用还是在变量上使用，变量使用 const 而属性使用 readonly。

## 额外属性检查

在之前的例子中我们使用了接口，TypeScript 允许我们的接口定义时的 `Shape` 为 `{ label: string; }` 但是对象的实际 `Shape` 为 `{ size: number; label: string; }`。我们也了解了可选属性，当创建具有动态属性的对象的时候非常有用。

但是如果将二者混用可能就会出些问题了，下面我们来看有关 `createSquare` 函数的最后一个例子。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}

let mySquare = createSquare({ colour: "red", width: 100 });
```

注意传给 createSquare 函数的参数是 `colour` 而不是 `color`，在一般的 JavaScript 语法中，这样传值会失败。

你可能会说程序没有什么问题啊，width 属性没有问题，只是 color 属性没有指定，但是没有 color 属性问题也不大嘛。

但是 TypeScript 认为代码中可能有 BUG，在将对象字面量分配给其他变量或将其作为参数传递时，会对其进行特殊处理并进行额外的属性检查，如果对象字面量含有任何目标类型没有的属性，将会返回错误。

*~这里着重介绍一下所谓的对象字面量，我们向 createSquare 函数传值有两种方法，一种是定义好对象后传入整个对象，一种是使用对象字面量，如下两种方式。*

定义好对象传入整个对象：
<!--JavaScript-->

```js
let x = {
  width: 1,
  color: "red"
}

let mySquare = createSquare(x);
```

使用对象字面量：
<!--JavaScript-->

```js
let mySquare = createSquare({width: 1, color: "red"});
```

*~这里所说的对象字面量就是指后一种传值方法。*

<!--JavaScript-->

```js
// error: Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?
let mySquare = createSquare({ colour: "red", width: 100 });
```

解决这些检查其实很简单，最简单的方法就是使用类型推断。
<!--JavaScript-->

```js
let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);
```

>*~其实也可以先把 `{ width: 100, opacity: 0.5 }` 提前定义好，使用一个变量来引用。*

但是如果你确定对象有一些额外的属性，添加字符串索引签名可能是更好的办法。如果 SquareConfig 有 color 和 width 属性，但是仍有一些其他属性，我们可以这样定义。
<!--JavaScript-->

```js
interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
```

接下来将讨论一下这种方式，这种方式的意思是 SquareConfig 可以有很多的属性，只要属性名不是 color 和 width，他们的类型无所谓。

解决这种语法检查的最后一种方法，大家可能有点惊讶，仅仅只需要把对象指定给一个变量就可以了，由于 squareOptions 不会进行过多的属性检查，所以编译器不会报错。
<!--JavaScript-->

```js
let squareOptions = { colour: "red", width: 100 };
let mySquare = createSquare(squareOptions);
```

只要在 squareOptions 和 SquareConfig 之间具有共有的属性，上面的方法就有效。在上面的例子中，width 就是二者都共有的属性。如果二者之间没有任何的公共属性，那么上面这种方法仍然会失效。
<!--JavaScript-->

```js
let squareOptions = { colour: "red" };
let mySquare = createSquare(squareOptions); // Error，两种类型没有共有的属性。
```

请记住，对于上述简单代码，或许不应该尝试去规避这些检查。对那些还含有方法和持有状态的复杂对象字面量，需要时刻注意这些技巧，大多数由额外属性造成的错误实际上都是程序 BUG。这意味着如果遇到像 `option bags` 那样的额外属性检查时，你可能需要修改一下类型声明。在这种情况下，如果传递具有 color 和 colour 属性的对象到 createSquare 函数没问题，那我们应该修正 SquareConfig 的定义。

## 函数类型

## 可索引类型

## 类类型

## 接口继承

## 混合类型

## 接口实现类
