---
id: 02变量声明_v3.7
title: 变量声明
---

`let` 和 `const` 是 JavaScript 中相对比较新的变量声明方式，[正如我们前面所述](./01数据类型_v3.7.html#关于-let)，`let` 在某些方面和 `var` 有些类似，但是 `let` 可以避免使用者在使用 JavaScript 编写代码时落入一些常见的陷阱。`const` 为 `let` 增加了一些特性，阻止变量被重新赋值。

TypeScript 是 JavaScript 的超集，自然支持 `let` 和 `const`，在这里，我们将详细说明这些新的声明方式以及为什么它们比 `var` 更可取。

如果你使用过 JavaScript，下面的部分将帮助你加深印象，如果你非常了解使用 `var` 声明变量的时候造成的令人迷惑的问题，那对你来说就很简单了。

## 使用 var

在 JavaScript 中声明变量我们习惯性地采用 `var` 关键字。
<!--JavaScript-->

```js
var a = 10;
```

你应该知道，代码声明了一个变量 `a`，它的值是 10。

我们也可以在函数中声明一个变量。
<!--JavaScript-->

```js
function f() {
    var message = "Hello, world!";

    return message;
}
```

我们也可以在其他的函数内部访问这些变量。
<!--JavaScript-->

```js
function f() {
    var a = 10;
    return function g() {
        var b = a + 1;
        return b;
    }
}

var g = f();
g(); // returns '11'
```

在上面的例子中，变量 g 使用了在函数 f 中声明的变量 a，当 g 被调动的时候，a 的值将于函数 f 中 a 的值绑定。就算 f 函数已经执行完成，a 的值仍然可以被访问或被修改。
<!--JavaScript-->

```js
function f() {
    var a = 1;

    a = 2;
    var b = g();
    a = 3;

    return b;

    function g() {
        return a;
    }
}

f(); // returns '2'
```

### 作用域规则

相比其他语言，用 `var` 声明的变量有一些奇怪的作用域规则，看下面的例子。
<!--JavaScript-->

```js
function f(shouldInitialize: boolean) {
    if (shouldInitialize) {
        var x = 10;
    }

    return x;
}

f(true);  // returns '10'
f(false); // returns 'undefined'
```

一些读者可能会去再试一遍这个例子，变量 x 在 if 代码块中声明了，我们可以从 if 代码块的外部访问它，因为 var 声明的变量可以在函数、模块、命名空间或者全局范围内的任何位置，这些我们后面都会详细描述。**~包含变量的代码段有些人称为 `var` 作用域或函数作用域，参数也是函数作用域。**

这些作用域规则会造成很多的错误，一个大问题是多次声明一个相同的变量不会出错。
<!--JavaScript-->

```js
function sumMatrix(matrix: number[][]) {
    var sum = 0;
    for (var i = 0; i < matrix.length; i++) {
        var currentRow = matrix[i];
        for (var i = 0; i < currentRow.length; i++) {
            sum += currentRow[i];
        }
    }

    return sum;
}
```

可以很容易地发现，内部 for 循环会意外覆盖变量 i，因为 i 引用的是同一函数作用域的变量，正如经验丰富的开发人员所知，类似的错误会贯穿代码审查，并可能让人感觉很有挫败感。

### 令人迷惑的变量

来看看下面这段代码的输出。
<!--JavaScript-->

```js
for (var i = 0; i < 10; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
```

`setTimeout` 将在指定的毫秒数之后尝试执行函数（**?though waiting for anything else to stop running**）。

准备好了吗？看看输出。
<!--JavaScript-->

```js
10
10
10
10
10
10
10
10
10
10
```

很多的 JavaScript 开发人员都熟悉这个问题，但是如果你感到惊讶，那么你也并不是第一个，大多数人期待的输出应该像下面这样。
<!--JavaScript-->

```js
0
1
2
3
4
5
6
7
8
9
```

还记得我们之前提到过的变量捕获吗？我们传递给 setTimeout 的每个函数表达式中的 i 实际上是同一个作用域中的同一个 i。

让我们看看这是什么意思，setTimeout 将在一定的毫秒数之后尝试执行函数，但是实际上是在 for 循环之后尝试执行函数（*~因为 for 循环的速度太快了，在 setTimeout 开始调用函数的时候，for 循环早已经执行完成*），在 for 循环结束之后，i 的值已经是 10 了，所以每一次 setTimeout 调用函数的时候都会打印 10。

常见的解决方法是使用 `IIFE` - an Immediately Invoked Function Expression，每一次迭代的时候捕获变量 i。
<!--JavaScript-->

```js
for (var i = 0; i < 10; i++) {
    // capture the current state of 'i'
    // by invoking a function with its current value
    (function(i) {
        setTimeout(function() { console.log(i); }, 100 * i);
    })(i);
}
```

这种看上去很奇怪的模式其实很常见，参数列表中的 i 实际上覆盖了 for 循环中声明的 i，但是由于我们给它们起了相同的名字，所以我们不必再去修改循环体里面的代码。

## 使用 let

现在你应该知道了 `var` 有很多的问题，这就是为什么引入 `let` 的原因，除了声明变量所使用的关键字不同以外，其他都和使用 `var` 没有区别。
<!--JavaScript-->

```js
let hello = "Hello!";
```

关键的不同并不在于语法，而在于语义，让我们深入讨论。

### 块级作用域

当一个变量使用 `1et` 声明的时候，它使用了所谓的词法作用域或者叫块级作用域，与 `var` 变量将自己暴露到其所在的函数作用域不同，块级作用域中的变量在包含它的最近的块之外是完全不可见的，甚至包括 for 循环。
<!--JavaScript-->

```js
function f(input: boolean) {
    let a = 100;

    if (input) {
        // Still okay to reference 'a'
        let b = a + 1;
        return b;
    }

    // Error: 'b' doesn't exist here
    return b;
}
```

上面的代码中有两个变量 a 和 b，a 的可见性被限制在函数体 f 内部，而 b 的可见性被限制在包含它的 if 代码块之中。

在 `catch` 语法中声明的变量的可见性也具有相同的规则。
<!--JavaScript-->

```js
try {
    throw "oh no!";
}
catch (e) {
    console.log("Oh well.");
}

// Error: 'e' doesn't exist here
console.log(e);
```

块级作用域中声明的变量的另外一个特性是：在它们声明之前，变量不能被读写，尽管变量在作用域里面都存在，从块级作用域开始直到变量被声明这中间的区域叫*暂时性死区*，这也就是变量在 `let` 声明之前不能使用的一种复杂说法，TypeScript 将在语法层面提示你这一点。
<!--JavaScript-->

```js
a++; // illegal to use 'a' before it's declared;
let a;
```

需要注意的是你仍然可以在声明之前使用块级作用域，**?The only catch is that it’s illegal to call that function before the declaration**。如果编译器的目标版本是 ES2015，运行环境将抛出异常，然而，目前 TypeScript 允许这样用而且不会认为这是错误的使用方式。
<!--JavaScript-->

```js
function foo() {
    // okay to capture 'a'
    return a;
}

// illegal call 'foo' before 'a' is declared
// runtimes should throw an error here
foo();

let a;
```

更多关于暂时性死区的内容，请查看 [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let) 上面相关的内容。

### 重复声明和覆盖

当使用 `var` 声明变量的时候，`var` 语法并不关心你的变量声明了多少次，你只会拿到一个变量。
<!--JavaScript-->

```js
function f(x) {
    var x;
    var x;

    if (true) {
        var x;
    }
}
```

在上面的例子中，所有关于 x 的声明实际上都指向同一个 x，这完全是合法的。而这通常也会成为 BUG 的来源，幸亏 `let` 语法没有那么的宽容。
<!--JavaScript-->

```js
let x = 10;
let x = 20; // error: can't re-declare 'x' in the same scope
```

TypeScript 在检查声明语法的时候不要求变量都必须是块级作用域。
<!--JavaScript-->

```js
function f(x) {
    let x = 100; // error: interferes with parameter declaration
}

function g() {
    let x = 100;
    var x = 100; // error: can't have both declarations of 'x'
}
```

并不是说块级作用域变量就不能使用函数作用域的方式来声明，块级作用域变量只要求变量所在的代码块不同就行。
<!--JavaScript-->

```js
function f(condition, x) {
    if (condition) {
        let x = 100;
        return x;
    }

    return x;
}

f(false, 0); // returns '0'
f(true, 0);  // returns '100'
```

在内部嵌套的块里面声明同样名称的变量的行为称为覆盖，它有点像一把双刃剑，因为它会在意外覆盖的情况下引入某些 BUG ，假设我们之前已经使用 let 变量编写了sumMatrix函数。
<!--JavaScript-->

```js
function sumMatrix(matrix: number[][]) {
    let sum = 0;
    for (let i = 0; i < matrix.length; i++) {
        var currentRow = matrix[i];
        for (let i = 0; i < currentRow.length; i++) {
            sum += currentRow[i];
        }
    }

    return sum;
}
```

循环实际执行的时候不会有代码错误，但是内部循环的 i 覆盖了外部循环的 i。

为了让代码更通俗易懂，平常应该避免变量覆盖，尽管在某些情况下它可能有那么点点用，你也应该遵循最佳实践（*~避免混淆*）。

### 块级作用域的变量

在之前我们使用 `var` 声明变量时，我们简要介绍了变量的行为。每次作用域启动的时候，都会创建变量的“环境”，该“环境”及其持有的变量即使在作用域内的所有任务都执行完毕后也可以存在。
<!--JavaScript-->

```js
function theCityThatAlwaysSleeps() {
    let getCity;

    if (true) {
        let city = "Seattle";
        getCity = function() {
            return city;
        }
    }

    return getCity();
}
```

因为我们持有运行环境的 city 变量，所以即便 if 代码块执行完成，我们仍然可以访问它。

再看之前的 `setTimeout` 的例子，我们需要使用 `IIFE` 来为 for 循环的每次迭代持有变量的状态。我们做的就是为持有的变量创造一个新的变量环境，代码看上去有些恶心，但是幸运的是，你再也不用在 TypeScript 中那样做了。

当 let 变量参与循环的时候，代码语义将完全不同。相比于在每次循环中引入新的变量环境，let 在每次迭代的时候创建一个全新的作用域，这件事之前我们是使用 `IIFE` 来做的，现在我们可以使用 `let` 来改造 setTimeout 这个例子了。
<!--JavaScript-->

```js
for (let i = 0; i < 10 ; i++) {
    setTimeout(function() { console.log(i); }, 100 * i);
}
```

正如预期的一样，输出如下。
<!--JavaScript-->

```js
0
1
2
3
4
5
6
7
8
9
```

## 使用 const

## let vs const

## 解构

### 数组解构

### 元组解构

### 对象解构

### 属性重命名

### 默认值

### 函数声明

### 重组
