---
id: 01数据类型_v3.7
title: 数据类型
---

## 简介

在编程时我们需要一些最简单的数据结构，比如：数字、字符串、结构体、布尔值等等，TypeScript 支持很多和 JavaScript 相同的数据类型，另外还有枚举类型。

## 布尔类型

最基本的数据类型是 true / false，在 JavaScript 和 TypeScript 中称为 `boolean` 值。
<!--JavaScript-->

```js
let isDone: boolean = false;  
```

## 数字类型

像 JavaScript 一样，TypeScript 中的所有数字都是浮点数值，这些浮点数值的类型称为 `number`。除了十六进制和十进制数字，TypeScript 还支持 ES2015 规范引入的二进制和八进制数字。

<!--JavaScript-->

```js
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
```

## 字符串

在 JavaScript 中创建 Web 页面和服务端程序的另一种重要的数据是文本数据，像其他语言一样，我们使用 `string` 类型来定义这些文本数据，和 JavaScript 一样，TypeScript 使用单引号 `'` 或双引号 `"` **~包裹**字符串相应的字符。
<!--JavaScript-->

```js
let color: string = "blue";
color = 'red';
```

还可以使用模板字符串，这种方式可以让定义的字符串跨行，同时内部可以嵌入表达式，模板字符串使用反引号 `` ` `` **~包裹**字符串，内嵌的表达式格式为 `${ expr }`。
<!--JavaScript-->

```js
let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${ fullName }.

I'll be ${ age + 1 } years old next month.`;
```

上面这段代码和下面的定义方式是一样的。
<!--JavaScript-->

```js
let sentence: string = "Hello, my name is " + fullName + ".\n\n" +
    "I'll be " + (age + 1) + " years old next month.";
```

## 数组

TypeScript 和 JavaScript 一样可以定义数组类型的数据，数组有两种定义方式，第一种方式可以使用数组内部元素的类型后跟 `[]` 的方式来定义数组。
<!--JavaScript-->

```js
let list: number[] = [1, 2, 3];
```

第二种方式使用 `Array<elemType>` 定义。
<!--JavaScript-->

```js
let list: Array<number> = [1, 2, 3];
```

## 元组

元组实际是一个定长的、每个位置元素类型确定的数组，但是这种数组内部元素的类型可以不一样。例如，你可能想表示一对由 `string` 和 `number` 构成的一个数据结构。
<!--JavaScript-->

```js
// 定义
let x: [string, number];
// 初始化
x = ["hello", 10]; // OK
// 错误的方式初始化
x = [10, "hello"]; // Error
```

当通过确定的索引（*~数字类型的值*）去检索元组时，将返回对应的数据（*~类型*）。
<!--JavaScript-->

```js
console.log(x[0].substring(1)); // OK
console.log(x[1].substring(1)); // Error, 'number' does not have 'substring'
```

当索引越界的时候将返回错误。
<!--JavaScript-->

```js
x[3] = "world"; // Error, Property '3' does not exist on type '[string, number]'.

console.log(x[5].toString()); // Error, Property '5' does not exist on type '[string, number]'.
```

## 枚举

枚举是对 JavaScript 数据类型的一个很有效的补充，枚举使用 `enum` 定义。就像在 C# 语言中一样，枚举是定义一组数字集合更友好（*~代码可读性更好*）的方式。
<!--JavaScript-->

```js
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
```

>*~枚举也可使用中文进行定义，`Color.绿色` 也是可以的。*

枚举默认对内部成员从 `0` 开始编号（*~枚举实际上就是数字，编号就是枚举每个成员的值*），你可以手动修改内部成员的编号。例如，我们可以让上面的枚举 Color 从 1 开始编号。
<!--JavaScript-->

```js
enum Color {Red = 1, Green, Blue}
let c: Color = Color.Green;
```

或者我们也可以手动指定所有枚举的编号。
<!--JavaScript-->

```js
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
```

枚举的一个很方便的功能是可以直接从数字值转换为枚举对应的名称（*~返回的名称是个 `string` 类型的值*）。例如，如果我们知道 `2` 这个数字值，但是我们不清楚该映射到上面的 Color 枚举的哪个成员，我们可以像下面这下查找对应的成员。
<!--JavaScript-->

```js
enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName); // 返回 Color 枚举的 Green 成员。
```

*~枚举成员的编号如果手动指定，则紧接着的下一个成员的编号将以前一个编号为基础按步长 `1` 递增，那这里就涉及一个问题了，看下面这个例子。*
<!--JavaScript-->

```js
enum Color {
  Red = 1,
  绿色 = 10,
  蓝色,
  白色 = 11
}

console.log(Color.蓝色); // line A
console.log(Color[11]); // line B
```

**$这个例子里面 A 行和 B 行分别输出什么值呢？各位看官自己试一试并想想原因，同时要注意避免在代码出现上面这个例子中的问题，可能会引起很多业务上的严重 BUG。**

## 任意值

有些时候我们需要定义我们并不清楚具体类型的数据，这些数据是动态生成的，例如来自用户或第三方库。在这种情况下，我们需要选择性地放弃类型检查让这些数据数据通过编译期类型检查，此时我们可以使用 `any` 标识这些数据。
<!--JavaScript-->

```js
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
```

`any` 类型可以和已有 JavaScript 代码协同工作，它可以让代码在编译过程中逐渐加入或退出类型检查，在其他语言中，你可能觉得是 `Object` 类型来扮演这个角色，但是 `Object` 类型的变量仅允许你为其指定任意值，你不能在变量上调用方法甚至是本来就存在的方法。
<!--JavaScript-->

```js
let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists 方法在运行时可能存在
notSure.toFixed(); // okay, toFixed 存在 (但编译器不会检查)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: 属性 'toFixed' 在 Object 类型上不存在
```

>*~ `any` 指的是通过编译期检查，并不是说适用于运行期，如果在运行时 `notSure` 对象并没有 `ifItExists` 函数，那么 `notSure.ifItExists();` 仍然会在运行时出错。上面代码中，`notSure` 在运行时的值为 4，而 `number` 类型的变量在原型链上是有 `toFixed()` 这个方法的。*

>**?Note: Avoid using `Object` in favor of the non-primitive object type as described in our [Do’s and Don’ts](https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html#general-types) section.**

`any` 类型也非常适合那种只知道部分数据类型的情况，比如创建一个元素是多种数据类型的数组。
<!--JavaScript-->

```js
let list: any[] = [1, true, "free"];

list[1] = 100;
```

## Void

`void` 的含义和 `any` 有些相反，`void` 表示没有任何的数据类型，通常你会在一个不返回任何值的函数的定义中看到这种用法。
<!--JavaScript-->

```js
function warnUser(): void {
    console.log("This is my warning message");
}
```

定义 `void` 类型的变量没有任何用，因为你仅仅只能为其赋值为 `null` （仅当未指定--strictNullChecks时，请参阅下一部分）或 `undefined`。
<!--JavaScript-->

```js
let unusable: void = undefined;
unusable = null; // OK 如果指定了 `--strictNullChecks` 参数
```

## Null 和 Undefined

在 TypeScript 中，null 和 undefined 都有各自的类型，分别为 `null` 和 `undefined`，像 `void` 一样，它们不是太有用。
<!--JavaScript-->

```js
// 不能为它们指定任何其他值
let u: undefined = undefined;
let n: null = null;
```

默认情况下，`null` 和 `undefined` 是其他所有类型的子类型，也就是说你可以指定 `null` 和 `undefined` 值给一个 `number` 类型的变量。

使用 `--strictNullChecks` 标志时，`null` 和 `undefined` 只能赋值给 `any` 类型的变量和它们各自类型的变量（一个例外是 `undefined` 是可以赋值给 `void` 类型的变量的），这能够避免许多常见的错误。**$如果想要赋值 `string` 或 `null` 或 `undefined` 给变量，你可以使用联合类型 `string | null | undefined` 来定义这个变量。**
<!--JavaScript-->

```js
let a: string | null | undefined;
a = "a string";
a = null;
a = undefined;
```

联合类型我们将在后面的章节中提到。

>注意：我们鼓励在可能的情况下使用 `--strictNullChecks` 参数，但是出于本手册的目的，我们将假定它已关闭。

## Never

`never` 表示永远不会出现值的类型，例如，`never` 作为函数的返回类型，或者始终抛出异常的箭头函数，或者一直不返回的函数（*~无限循环*）。**?Variables also acquire the type never when narrowed by any type guards that can never be true.**

`never` 类型是所有类型的子类型，也可以赋值给任何类型，`never` 没有子类型，任何类型的值也不能赋值给 `never`（除了 `never` 自身），甚至 `any` 类型的值也不能赋值给 `never` 变量。

如下是一些返回 `never` 的函数。
<!--JavaScript-->

```js
// 返回 `never` 的函数不能有正常执行完成标志位。
function error(message: string): never {
    throw new Error(message);
}

// 推断返回值也是 `never`，虽然没有明确指定。
function fail() {
    return error("Something failed");
}

// 返回 `never` 的函数不能有正常执行完成标志位。
function infiniteLoop(): never {
    while (true) {
    }
}
```

## Object

`object` 类型用来表示非简单类型，例如，任何不是 `number`、`string`、`boolean`、`bigint`、`symbol`、`null`、`undefined`的类型。

使用 `object` 类型，可以更好地表示 `Object.create` 之类的 API。例如：
<!--JavaScript-->

```js
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```

## 类型断言

>~对应Java中的 `类型强转`。

有时候你可能会遇到比 TypeScript 更了解值的类型的情况，通常指的是我们清楚地知道某个实体变量的类型比当前定义的类型更为明确的情况。

类型断言告诉编译器：“相信我，我清楚我在做什么！”，类型断言和其他语言中的类型强转类似，但是类型断言不对数据本身做特殊检查或改造数据结构，它不影响运行时，仅仅是在编译期被编译器使用，TypeScript 假定你已经执行了任何必要的特殊检查。

类型断言有两种形式，一种是单书名号的语法。
<!--JavaScript-->

```js
let someValue: any = "this is a string";

let strLength: number = (<string>someValue).length;
```

另外一种是 `as` 语法。
<!--JavaScript-->

```js
let someValue: any = "this is a string";

let strLength: number = (someValue as string).length;
```

两种方式是一样的，随便选择哪一种都行，但是，当在 `JSX` 中使用 TypeScript 的时候，只能使用 `as` 语法（*~因为单书名号方式，JSX 会把它当做一个组件进行解释*）。

## 关于 let

到现在你可能已经注意到了，我们一直在使用 `let` 替代你可能更熟悉的 JavaScript 中的 `var`，`let` 是在 ES2015 规范中引入的，现在已经快成为一个标准了，因为它比 `var` 更安全，我们将在后续讨论相关细节。使用 `let` 可以避免很多 JavaScript 中的常见问题，所以你应该尽可能地使用它来代替 `var`。
